//! This file is automatically generated using psxunittest:
//! https://github.com/daeken/psxunittest
//!
//! /!\ DO NOT EDIT DIRECTLY /!\

use gpu::{Gpu, VideoClock};
use gpu::renderer::{Renderer, PrimitiveAttributes, Vertex};
use memory::{Interconnect, Addressable};
use memory;
use debugger::DummyDebugger;
use shared::SharedState;
use bios::Bios;

use super::{Cpu, RegisterIndex};

/// Dummy GPU renderer to run the tests
struct DummyRenderer;

impl Renderer for DummyRenderer {
    fn set_draw_offset(&mut self, _: i16, _: i16) {
    }

    fn set_draw_area(&mut self, _: (u16, u16), _: (u16, u16)) {
    }

    fn set_display_mode(&mut self,
                        _: (u16, u16),
                        _: (u16, u16),
                        _: bool) {
    }

    fn push_line(&mut self, _: &PrimitiveAttributes, _: &[Vertex; 2]) {
    }

    fn push_triangle(&mut self, _: &PrimitiveAttributes, _: &[Vertex; 3]) {
    }

    fn push_quad(&mut self, _: &PrimitiveAttributes, _: &[Vertex; 4]) {
    }

    fn fill_rect(&mut self,
                 _: [u8; 3],
                 _: (u16, u16),
                 _: (u16, u16)) {
    }

    fn load_image(&mut self,
                  _: (u16, u16),
                  _: (u16, u16),
                  _: &[u16]) {
    }
}

fn load_blob(cpu: &mut Cpu,
             load_address: u32,
             blob: &[u32]) {
    let ram = cpu.interconnect_mut().ram_mut();

    for (i, &w) in blob.iter().enumerate() {
        ram.store::<memory::Word>(load_address + (i * 4) as u32, w);
    }
}

fn load<T: Addressable>(cpu: &mut Cpu,
                        load_address: u32,
                        v: u32) {
    let ram = cpu.interconnect_mut().ram_mut();

    ram.store::<T>(load_address, v);
}

#[test]
fn test_dummy() {
    let bios = Bios::dummy();
    let gpu = Gpu::new(VideoClock::Ntsc);
    let inter = Interconnect::new(bios, gpu, None);
    let mut cpu = Cpu::new(inter);
    let mut shared = SharedState::new();
    let mut debugger = DummyDebugger;
    let mut renderer = DummyRenderer;

    for r in 0..31 {
        cpu.set_reg(RegisterIndex(r), 0);
    }

    cpu.set_reg(RegisterIndex(1), 0xffffffff);

    load_blob(&mut cpu, 0x80100000,
              &[0x3401002a,
                0x0bab6fb8,
                0x00000000]);

    cpu.set_pc(0x80100000);

    let mut timeout = true;
    for _ in 0..TIMEOUT {
        if (cpu.pc & 0x0fffffff) == 0xeadbee0 {
            timeout = false;
            break;
        }
        cpu.run_next_instruction(&mut debugger, &mut shared, &mut renderer);
    }
    assert!(timeout == false);

    assert!(cpu.regs[1] == 0x2a);
}

#[test]
fn test_beq() {
    let bios = Bios::dummy();
    let gpu = Gpu::new(VideoClock::Ntsc);
    let inter = Interconnect::new(bios, gpu, None);
    let mut cpu = Cpu::new(inter);
    let mut shared = SharedState::new();
    let mut debugger = DummyDebugger;
    let mut renderer = DummyRenderer;

    for r in 0..31 {
        cpu.set_reg(RegisterIndex(r), 0);
    }

    cpu.set_reg(RegisterIndex(1), 0x1);
    cpu.set_reg(RegisterIndex(2), 0x2);
    cpu.set_reg(RegisterIndex(3), -1i32 as u32);
    cpu.set_reg(RegisterIndex(4), 0xffffffff);

    load_blob(&mut cpu, 0x80100000,
              &[0x10220005,
                0x00000000,
                0x200a0001,
                0x10640004,
                0x00000000,
                0x200b0001,
                0x200a0002,
                0x00000000,
                0x00000000,
                0x0bab6fb8,
                0x00000000]);

    cpu.set_pc(0x80100000);

    let mut timeout = true;
    for _ in 0..TIMEOUT {
        if (cpu.pc & 0x0fffffff) == 0xeadbee0 {
            timeout = false;
            break;
        }
        cpu.run_next_instruction(&mut debugger, &mut shared, &mut renderer);
    }
    assert!(timeout == false);

    assert!(cpu.regs[10] == 0x1);
    assert!(cpu.regs[11] == 0);
}

#[test]
fn test_branch_in_branch_delay() {
    let bios = Bios::dummy();
    let gpu = Gpu::new(VideoClock::Ntsc);
    let inter = Interconnect::new(bios, gpu, None);
    let mut cpu = Cpu::new(inter);
    let mut shared = SharedState::new();
    let mut debugger = DummyDebugger;
    let mut renderer = DummyRenderer;

    for r in 0..31 {
        cpu.set_reg(RegisterIndex(r), 0);
    }


    load_blob(&mut cpu, 0x80100000,
              &[0x10000002,
                0x10000004,
                0x20030001,
                0x20010001,
                0x10000002,
                0x00000000,
                0x20020001,
                0x00000000,
                0x0bab6fb8,
                0x00000000]);

    cpu.set_pc(0x80100000);

    let mut timeout = true;
    for _ in 0..TIMEOUT {
        if (cpu.pc & 0x0fffffff) == 0xeadbee0 {
            timeout = false;
            break;
        }
        cpu.run_next_instruction(&mut debugger, &mut shared, &mut renderer);
    }
    assert!(timeout == false);

    assert!(cpu.regs[1] == 0x1);
    assert!(cpu.regs[2] == 0);
    assert!(cpu.regs[3] == 0);
}

#[test]
fn test_add_1() {
    let bios = Bios::dummy();
    let gpu = Gpu::new(VideoClock::Ntsc);
    let inter = Interconnect::new(bios, gpu, None);
    let mut cpu = Cpu::new(inter);
    let mut shared = SharedState::new();
    let mut debugger = DummyDebugger;
    let mut renderer = DummyRenderer;

    for r in 0..31 {
        cpu.set_reg(RegisterIndex(r), 0);
    }

    cpu.set_reg(RegisterIndex(1), 0xa);
    cpu.set_reg(RegisterIndex(2), -15i32 as u32);

    load_blob(&mut cpu, 0x80100000,
              &[0x00201820,
                0x00222020,
                0x00412820,
                0x00423020,
                0x0bab6fb8,
                0x00000000]);

    cpu.set_pc(0x80100000);

    let mut timeout = true;
    for _ in 0..TIMEOUT {
        if (cpu.pc & 0x0fffffff) == 0xeadbee0 {
            timeout = false;
            break;
        }
        cpu.run_next_instruction(&mut debugger, &mut shared, &mut renderer);
    }
    assert!(timeout == false);

    assert!(cpu.regs[1] == 0xa);
    assert!(cpu.regs[2] == -15i32 as u32);
    assert!(cpu.regs[3] == 0xa);
    assert!(cpu.regs[4] == -5i32 as u32);
    assert!(cpu.regs[5] == -5i32 as u32);
    assert!(cpu.regs[6] == -30i32 as u32);
}

#[test]
fn test_arithmetic_branching_test() {
    let bios = Bios::dummy();
    let gpu = Gpu::new(VideoClock::Ntsc);
    let inter = Interconnect::new(bios, gpu, None);
    let mut cpu = Cpu::new(inter);
    let mut shared = SharedState::new();
    let mut debugger = DummyDebugger;
    let mut renderer = DummyRenderer;

    for r in 0..31 {
        cpu.set_reg(RegisterIndex(r), 0);
    }

    cpu.set_reg(RegisterIndex(2), 0xdead);
    cpu.set_reg(RegisterIndex(3), 0);
    cpu.set_reg(RegisterIndex(5), 0x1);

    load_blob(&mut cpu, 0x80100000,
              &[0x00451023,
                0x24630001,
                0x1c40fffd,
                0x00000000,
                0x0bab6fb8,
                0x00000000]);

    cpu.set_pc(0x80100000);

    let mut timeout = true;
    for _ in 0..TIMEOUT {
        if (cpu.pc & 0x0fffffff) == 0xeadbee0 {
            timeout = false;
            break;
        }
        cpu.run_next_instruction(&mut debugger, &mut shared, &mut renderer);
    }
    assert!(timeout == false);

    assert!(cpu.regs[2] == 0);
    assert!(cpu.regs[3] == 0xdead);
    assert!(cpu.regs[5] == 0x1);
}

#[test]
fn test_unaligned_loads() {
    let bios = Bios::dummy();
    let gpu = Gpu::new(VideoClock::Ntsc);
    let inter = Interconnect::new(bios, gpu, None);
    let mut cpu = Cpu::new(inter);
    let mut shared = SharedState::new();
    let mut debugger = DummyDebugger;
    let mut renderer = DummyRenderer;

    for r in 0..31 {
        cpu.set_reg(RegisterIndex(r), 0);
    }

    load::<memory::Word>(&mut cpu, 0xbee0, 0xdeadbeef);
    cpu.set_reg(RegisterIndex(30), 0xbee1);

    load_blob(&mut cpu, 0x80100000,
              &[0x83c10000,
                0x93c20000,
                0x0bab6fb8,
                0x00000000]);

    cpu.set_pc(0x80100000);

    let mut timeout = true;
    for _ in 0..TIMEOUT {
        if (cpu.pc & 0x0fffffff) == 0xeadbee0 {
            timeout = false;
            break;
        }
        cpu.run_next_instruction(&mut debugger, &mut shared, &mut renderer);
    }
    assert!(timeout == false);

    assert!(cpu.regs[1] == -66i32 as u32);
    assert!(cpu.regs[2] == 0xbe);
    assert!(cpu.regs[3] == 0);
    assert!(cpu.regs[4] == 0);
}

#[test]
fn test_load_delay_for_cop() {
    let bios = Bios::dummy();
    let gpu = Gpu::new(VideoClock::Ntsc);
    let inter = Interconnect::new(bios, gpu, None);
    let mut cpu = Cpu::new(inter);
    let mut shared = SharedState::new();
    let mut debugger = DummyDebugger;
    let mut renderer = DummyRenderer;

    for r in 0..31 {
        cpu.set_reg(RegisterIndex(r), 0);
    }

    cpu.set_reg(RegisterIndex(2), 0x80110000);
    load::<memory::Word>(&mut cpu, 0x80110000, 0xdeadbeef);

    load_blob(&mut cpu, 0x80100000,
              &[0x8c430000,
                0x00000000,
                0x4803c800,
                0x10600004,
                0x00000000,
                0x20010001,
                0x0804000a,
                0x00000000,
                0x20010002,
                0x0804000a,
                0x0bab6fb8,
                0x00000000]);

    cpu.set_pc(0x80100000);

    let mut timeout = true;
    for _ in 0..TIMEOUT {
        if (cpu.pc & 0x0fffffff) == 0xeadbee0 {
            timeout = false;
            break;
        }
        cpu.run_next_instruction(&mut debugger, &mut shared, &mut renderer);
    }
    assert!(timeout == false);

    assert!(cpu.regs[3] == 0);
    assert!(cpu.regs[1] == 0x1);
}

#[test]
fn test_multiple_load_cancelling() {
    let bios = Bios::dummy();
    let gpu = Gpu::new(VideoClock::Ntsc);
    let inter = Interconnect::new(bios, gpu, None);
    let mut cpu = Cpu::new(inter);
    let mut shared = SharedState::new();
    let mut debugger = DummyDebugger;
    let mut renderer = DummyRenderer;

    for r in 0..31 {
        cpu.set_reg(RegisterIndex(r), 0);
    }

    load::<memory::Word>(&mut cpu, 0, 0x7001a7e);
    cpu.set_reg(RegisterIndex(1), 0x600dc0de);

    load_blob(&mut cpu, 0x80100000,
              &[0x40016000,
                0x8c010000,
                0x40017800,
                0x8c010000,
                0x8c010000,
                0x00201021,
                0x0bab6fb8,
                0x00000000]);

    cpu.set_pc(0x80100000);

    let mut timeout = true;
    for _ in 0..TIMEOUT {
        if (cpu.pc & 0x0fffffff) == 0xeadbee0 {
            timeout = false;
            break;
        }
        cpu.run_next_instruction(&mut debugger, &mut shared, &mut renderer);
    }
    assert!(timeout == false);

    assert!(cpu.regs[1] == 0x7001a7e);
    assert!(cpu.regs[2] == 0x600dc0de);
}

/// Number of CPU cycles after which we consider the test to be a
/// failure
const TIMEOUT: usize = 1_000_000;

